const 是 constant 的缩写，本意是**不变的**，**不易改变**的意思。在 C++ 中用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数。

## 1. 修饰普通类型的变量

对于基本的数据类型，修饰符 cosnt 可以在类型说明符前，也可以用在类型说明符后面，其结果是一样的。

```cpp
const int a = 5;
int const b = 5;
const int arr1[3] = {1,2,3};
int const arr2[3] = {1,2,3};
```

来看一些对 const 变量的操作：

```cpp
const int a = 10;
a = 11;				// 错误：不能为 const 变量赋新值
int &b = a;			// 错误：不能为 cosnt 变量绑定 non-const 引用
const int &c = a;	// 正确
int *d = &a;		// 错误：不能为 const 变量绑定指向 non-const 的指针
const int *e = &a;	// 正确

```

const 与 define 宏定义的区别：

1. **处理阶段不同**：define 是在预处理阶段，define 常量不会被编译器看到，因为在预处理阶段已经替换了；const 常量在编译阶段使用。
2. **类型和安全检查**不同：define 没有类型，不做检查，仅仅是字符替换；const常量有明确的类型，在编译阶段进行类型检查；
3. **存储方式**不同：define 是字符替换，有多少地方使用，就会替换多少次，不会分配内存；编译器通常不会为 const 常量分配空间，只是将他们保存在符号表内，使它们成为一个编译期间的常量，没有读取内存的操作，效率也很高。

## 2. 修饰指针变量

const 修饰指针变量有三种情况：

### 2.1 const 修饰指针指向的内容，则内容为不可变量

```cpp
const int *p = 8;
```

const 修饰指针内容，即 *p 的值不可变，只能为8。因为 const 位于 * 的左边，称为**左定值**。

### 2.2 const 修饰指针，则指针为不可变量

```cpp
int a = 8;
int* const p = &a;
*p = 9;	// 正确
int b = 7;
p = &b;	// 错误
```

对于 const 指针 p 其指向的内存地址不能改变，但其内容可以改变，称为**右定向**，因为 cosnt 位于 * 右边。

### 2.3 cosnt 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量

```cpp
int a = 8;
const int* const p = &a;
```

这时 p 只想的内容和指向内容地址都已固定，不可改变。



## 3. 修饰函数参数和返回值

### 3.1 修饰函数参数

1. **值传递的 cosnt 修饰**：一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值；
2. **const 修饰指针参数**：防止指针被修改；
3. **cosnt 修饰引用参数**：为了增加效率（因为参数为引用不会创建副本）的同时防止被修改，对一般的 int、double 等内置类型，不采用引用的传递方式。

### 3.2 修饰函数返回值

1. **修饰内置类型**的返回值，这种情况实际无意义，因为参数返回本身就是赋值。
2. **修饰自定义类型**的返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
3. **修饰指针或引用**的返回值，保证指针指向内容不被改变。

## 4. 修饰类的成员变量和成员函数

### 4.1 类的成员变量

const 修饰类的成员变量，表示该成员为常量，不能不修改，只能在初始化列表中赋值。

```cpp
class A
{
…
const int nValue; //成员常量不能被修改
…
A(int x): nValue(x) { } ; //只能在初始化列表中赋值
}
```

### 4.2 类的成员函数

const 修饰类的成员函数，表示该成员函数不能修改类中的任何非 const 成员变量，一般 const 卸载函数的后面，比如 `void func() const;`。

如果有个成员函数想修改对象中的某一个成员变量，可以使用 **mutable** 关键字修饰这个成员变量：

```cpp
#include<iostream>
using namespace std;
class Test
{
public:
    Test(int _m,int _t):_cm(_m),_ct(_t){}
    void Kf()const
    {
        ++_cm; // 错误
        ++_ct; // 正确
    }
private:
    int _cm;
    mutable int _ct;
};
 
int main(void)
{
    Test t(8,7);
    return 0;
}
```





